import type { NextPage } from "next";
import { useRouter } from "next/router";
import { useEffect, useState } from "react";
import { PageConfig, ContentConfig, PoolInfo } from "../constants/type";
import sty from "../styles/Sell.module.scss";

/** components */
import PageLayout from "../components/PageLayout";
import ContentLayout from "../components/ContentLayout";
import LabelInputButton from "../components/Input/LabelInputButton";
import { useAccount, useSigner } from "wagmi";
import { useEthersSigner } from "../hooks";
import {
  callAllowance,
  callBalance,
  formatInputFloat,
  formatPoolInfo,
  getPoolInfo,
  sendApprove,
  sendTransfer,
  writeMaxOutLock,
  writeNewOwner,
  writePrice,
  writeSubReserve,
} from "../utils";
import { utils, ethers } from "ethers";

const pageConfig: PageConfig = {
  title: "Set Pool",
  description: "Generated by @rainbow-me/create-rainbowkit",
};

const contentConfig: ContentConfig = {
  title: "SetPool",
  back: "",
};

const SetPool: NextPage = () => {
  const router = useRouter();
  const { poolAddress, tokenAddress } = router.query;
  const { address } = useAccount();
  const signer = useSigner();
  const ethersSigner = useEthersSigner(address, signer.data);

  const [poolInfo, setPoolInfo] = useState<PoolInfo | null>(null);
  const [maxOutLock, setMaxOutLock] = useState<string>("");
  const [price, setPrice] = useState<string>("");
  const [owner, setOwner] = useState<string>("");
  const [reserve, setReserve] = useState<string>("");
  const [transferAmount, setTransferAmount] = useState<string>("");

  const getPoolHandle = async () => {
    if (!ethersSigner || !address || !poolAddress) return;
    const pool: string = String(poolAddress);
    const poolInfoRes = await getPoolInfo(ethersSigner, pool);
    if (poolInfoRes) {
      const info = formatPoolInfo(poolInfoRes);
      setPoolInfo(info);
      setMaxOutLock(String(info.maxOutLock));
      setPrice(String(info.price));
      setOwner(String(info.owner));
      setReserve(String(info.balance));
    }
  };
  useEffect(() => {
    getPoolHandle();
  }, [ethersSigner]);

  const HandleMaxOutLock = async (v: string) => {
    if (maxOutLock == v) return;
    try {
      const pool: string = String(poolAddress);
      if (!ethersSigner || !address || !utils.isAddress(pool)) return;
      const tx = await writeMaxOutLock(ethersSigner, utils.getAddress(pool), [v]);
      if (tx) setMaxOutLock(v);
    } catch (error) {
      console.error(`Failed to handle max out lock: ${error}`);
    }
  };

  const HandlePrice = async (v: string) => {
    if (maxOutLock == v) return;
    try {
      const pool: string = String(poolAddress);
      if (!ethersSigner || !address || !utils.isAddress(pool)) return;
      const tx = await writePrice(ethersSigner, utils.getAddress(pool), [v]);
      if (tx) setPrice(v);
    } catch (error) {
      console.error(`Failed to handle price: ${error}`);
    }
  };

  const HandleNewOwner = async (v: string) => {
    if (owner == v) return;
    try {
      const pool: string = String(poolAddress);
      if (!ethersSigner || !address || !utils.isAddress(pool)) return;
      const tx = await writeNewOwner(ethersSigner, utils.getAddress(pool), [utils.getAddress(v)]);
      if (tx) getPoolHandle();
    } catch (error) {
      console.error(`Failed to handle new owner: ${error}`);
    }
  };

  const HandleSubReserve = async (v: string) => {
    try {
      const pool: string = String(poolAddress);
      const token: string = String(tokenAddress);
      if (!ethersSigner || !address || !utils.isAddress(pool)) return;
      const tx = await writeSubReserve(ethersSigner, utils.getAddress(pool), [v, address]);
      if (tx) {
        const balance = await callBalance(ethersSigner, [token, pool]);
        if (balance) setReserve(utils.formatEther(balance));
      }
    } catch (error) {
      console.error(`Failed to handle sub reserve: ${error}`);
    }
  };

  const HandleAddReserve = async (v: string) => {
    try {
      const pool: string = String(poolAddress);
      const token: string = String(tokenAddress);
      const amount = utils.parseEther(v);
      // check
      if (amount.isZero() || !ethersSigner || !address || !utils.isAddress(pool)) return;
      const ownerBalance = await callBalance(ethersSigner, [token, address]);
      // check
      if (ownerBalance?.lt(amount)) return;
      const tx = await sendTransfer(ethersSigner, [token, pool, amount]);
      // check
      if (tx) {
        const balance = await callBalance(ethersSigner, [token, pool]);
        if (balance) {
          setReserve(utils.formatEther(balance));
          setTransferAmount("");
        }
      }
    } catch (error) {
      console.error(`Failed to handle add reserve: ${error}`);
    }
  };

  return (
    <PageLayout pageConfig={pageConfig}>
      <ContentLayout contentConfig={contentConfig}>
        <div className={sty.boldRow}>
          Token: <span className={sty.lightText}>{String(tokenAddress).toLocaleLowerCase()}</span>
        </div>
        <div className={sty.boldRow}>
          Pool: <span className={sty.lightText}>{String(poolAddress).toLocaleLowerCase()}</span>
        </div>
        <div className={sty.inputRow}>
          <LabelInputButton
            label="MaxOutLock"
            value={maxOutLock}
            onClick={HandleMaxOutLock}
            onInput={formatInputFloat}
            placeholder="Set New MaxOutLock"
            type="text"
          />
          <LabelInputButton
            label="Price"
            value={price}
            onClick={HandlePrice}
            onInput={formatInputFloat}
            placeholder="Set New Price"
            type="text"
          />
          <LabelInputButton
            label="Owner"
            value={owner}
            onClick={HandleNewOwner}
            placeholder="Set New Owner"
            type="text"
          />
          <LabelInputButton
            label="Reserve"
            value={reserve}
            onClick={HandleSubReserve}
            onInput={formatInputFloat}
            placeholder="SubReserve"
            type="text"
            btnText="Sub"
          />
        </div>
        <div className={sty.transferInputRow}>
          <div className={sty.group}>
            <input
              type="text"
              value={transferAmount}
              className={sty.input}
              onInput={formatInputFloat}
              onChange={(e: any) => setTransferAmount(String(e.target.value))}
              placeholder="AddReserve To Pool..."
            />
            <button className={sty.btn} onClick={() => HandleAddReserve(transferAmount)}>
              Transfer
            </button>
          </div>
        </div>
      </ContentLayout>
    </PageLayout>
  );
};

export default SetPool;
